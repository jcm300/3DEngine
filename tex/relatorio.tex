\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{amsmath}

\begin{document}

\title{\vspace*{\fill}3D Engine}
\author{João Vieira (a78468) \and José Martins (a78821) \and Miguel Quaresma (a77049) \and Simão Barbosa (a77689)}
\date{%
    Universidade do Minho\\
    Computação Gráfica\\[2ex]%
    \today\vspace*{\fill}
}
\maketitle

\newpage

\tableofcontents

\newpage

\section{Introdução}
Este documento serve de documentação à implementação do generator bem como engine desenvolvidos com o intuito de no futuro ser possível a construção de sistemas planetários virtualmente e graficamente.

\newpage

\section{1ª Fase}

\subsection{Generator}

O Generator é o programa responsável por criar os ficheiros pretendidos pelo utilizador, estes contêm os pontos necessários para o Engine conseguir interpretar e "desenhar" os modelos pretendidos.
O programa está construído de forma a poder responder a pedidos relacionados com 4 objetos:
\begin{itemize}
    \item Um plano em XZ, que recebe como parâmetros x e z
        \begin{verbatim}
exº : ./generator plane 2 4 plane.3d
        \end{verbatim}
    \item Uma caixa, que recebe como parâmetros x, y, z e opcionalmente o número de divisões da mesma
        \begin{verbatim}
exº : ./generator box 2 3 2 box.3d
exº : ./generator box 2 3 2 5 box.3d
        \end{verbatim}
    \item Uma esfera, que recebe o raio, o número de slices e de stacks como parâmetros
        \begin{verbatim}
exº : ./generator sphere 3 10 20 sphere.3d
        \end{verbatim}
    \item Um cone, que recebe o seu raio e altura, bem como o número de slices e stacks como parâmetros
        \begin{verbatim}
exº : ./generator cone 2 4 10 20 cone.3d
        \end{verbatim}
\end{itemize}
Para além disto, optamos por também seguir a sugestão do enunciado e imprimir na primeira linha dos ficheiros (que contém os pontos a desenhar) o número de pontos que este contém. Isto permitirá alocar o espaço necessário aos \textit{arrays} usados para VBO's por forma a aumentar a performance do motor.

\subsection{Plano (Plane)}

O plano é o modelo mais simples das opções apresentadas, sabendo logo de partida que recebendo apenas os seus dois parâmetros (x e z) apenas é necessário desenhar 2 triângulos para representar o mesmo, ou seja, apenas necessitámos de preencher o ficheiro desejado com 6 pontos, de modo a ser tratado de forma pretendida pelo Engine.

\begin{figure}[ht!]
\centering
\includegraphics[height=7cm]{plane.png}
\caption{Resultado obtido passando o ficheiro gerado pelo Generator com os parâmetros x=2 e z=4 ao Engine}
\end{figure}

\subsubsection{Em termos matemáticos}
Seja:
\begin{itemize}
    \item x: valor da aresta paralela ao eixo x
    \item z: valor da aresta paralela ao eixo z
\end{itemize}
De modo a desenhar 2 triângulos são necessários 6 pontos:
\begin{itemize}
    \item triângulo 1
        \begin{itemize}
            \item ponto 1: (-x/2,0,z/2)
            \item ponto 2: (-x/2,0,-z/2)
            \item ponto 3: (x/2,0,z/2)
        \end{itemize}
    \item triângulo 2
        \begin{itemize}
            \item ponto 1: (-x/2,0,-z/2)
            \item ponto 2: (x/2,0,-z/2)
            \item ponto 3: (x/2,0,z/2)
        \end{itemize}
\end{itemize}

\begin{figure}[ht!]
\centering
\includegraphics[height=7cm]{planeMath.png}
\end{figure}

\subsection{Caixa (Box)}

Na caixa foi feita a assunção de que o seu centro se encontra na origem do gráfico ou seja, no ponto com coordenadas (0,0,0).
Tendo isto em conta, é-nos útil dividir os parâmetros recebidos das dimensões pretendidas por 2, sendo assim utilizados esses mesmos valores para cada um dos pontos positivos e negativos do eixo em causa.
Interpretamos as divisões opcionais da caixa (d) como sendo utilizadas para dividir as faces laterais da caixa em d divisões (no eixo y), e também em d divisões nas faces inferiores e superiores (no eixo x).
Tendo uma caixa 6 faces, e considerando que cada face é um paralelogramo cujos lados formam um ângulo de 90º entre si, é fácil calcular qual o número de pontos necessários a imprimir para ser possível desenhar o modelo:
\begin{itemize}
    \item 1 paralelogramo cujos lados formam um ângulo de 90º entre si é desenhado recorrendo a 2 triângulos
    \item 1 triângulo é desenhado recorrendo a 3 pontos
    \item Logo, cada paralelogramo cujos lados formam um ângulo de 90º entre si necessita de 6 pontos
    \item Com a componente opcional das divisões, cada face passa assim a ter d paralelogramos cujos lados formam um ângulo de 90º entre si.
    \item Ou seja, nº de pontos total = (2 * d + 4 * d) * 6
\end{itemize}
O processo com as divisões é simples, por exemplo, nas faces laterais da caixa, declaramos 2 variáveis y1 e y2 (sendo neste caso as divisões feitas no eixo y), começamos por calcular a variação em altura que cada divisão tem (var\_y = y/d) e atribuímos os valores:
\begin{itemize}
    \item y1 = -y;
    \item y2 = -y + var\_y;
\end{itemize}
A partir daqui e com a utilização de um ciclo com a inicialização da uma variável i a 0 e enquanto a mesma for menor que o número de divisões pretendidas d, utilizamos as funções criadas por nós para obter os pontos dos paralelogramos cujos lados formam um ângulo de 90º entre si/divisões das faces da caixa progressivamente (neste caso, faceYZ() e faceXY()), incrementando o valor de i, e aumentando em var\_y os valores de y1 e y2 no fim de cada iteração.

\begin{figure}[ht!]
\centering
\includegraphics[height=7cm]{box.png}
\caption{Resultado obtido passando o ficheiro gerado pelo Generator com os parâmetros correspondentes a uma box com 5 divisões ao Engine}
\end{figure}

\subsubsection{Em termos Matemáticos}
Não considerando divisões, ou seja apenas 2 triângulos por face, seja:
\begin{itemize}
    \item xI: valor das arestas paralelas ao eixo x (input 1)
    \item yI: valor das arestas paralelas ao eixo y (input 2)
    \item zI: valor das arestas paralelas ao eixo z (input 3)
\end{itemize}
Visto que a Box tem de estar centrada na origem estes valores são divididos por 2 de modo a facilitar os cálculos:
\begin{itemize}
    \item x=xI/2
    \item y=yI/2
    \item z=zI/2
\end{itemize}
Com base na seguinte figura:
\begin{figure}[H]
    \centering
    \includegraphics[height=10cm]{boxMath1.png}
\end{figure}
Os vértices da box são:
\begin{itemize}
    \item A = (-x,-y,z)
    \item B = (x,-y,z)
    \item C = (-x,y,z)
    \item D = (x,y,z)
    \item E = (-x,y,-z)
    \item F = (-x,-y,-z)
    \item G = (x,-y,-z)
    \item H = (x,y,-z)
\end{itemize}
Consideremos agora apenas as faces ABCD e EFGH:
\begin{figure}[H]
    \centering
    \includegraphics[height=5cm]{boxMath2.png}
\end{figure}
Para desenhar as faces(2 triângulos por cada face) as ordens dos pontos seria, por exemplo:
\begin{figure}[H]
    \centering
    \includegraphics[height=5cm]{boxMath3.png}
\end{figure}
Entre os pontos B e G e entre os pontos C e E apenas é alterado a coordenada z que é simétrica. Sendo assim, na função faceXY podemos (chamando duas vezes a função, uma com zParâmetro=z e outra com zParâmetro=-z) desenhar as duas faces sendo que, os pontos B e G são desenhados pela mesma expressão(x,-y,zParâmetro) e os C e E também(-x,y,zParâmetro). Para os outros pontos é usado um if e consoante o valor de z é desenhado os pontos correspondentes:
\begin{verbatim}
//triângulo 1 da face ABCD(z>0) ou triângulo 2 da face EFGH(z<0)
(x,-y,zParâmetro) //desenhar B ou G
(-x,y,zParâmetro) // desenhar C ou E
if(z>0) (-x,-y,zParâmetro) //desenhar A
else (x,y,zParâmetro) //desenhar H

//triângulo 2 da face ABCD(z>0) ou triângulo 1 da face EFGH(z<0)
(x,-y,zParâmetro) //desenhar B ou G
if(z>0) (x,y,zParâmetro) //desenhar D
else (-x,-y,zParâmetro) //desenhar F
(-x,y,zParâmetro) // desenhar C ou E
\end{verbatim}
Isto é aplicado às outras faces mudando a coordenada simétrica:
\begin{itemize}
    \item faces paralelas a YZ: coordenada x (função faceYZ)
    \item faces paralelas a XZ: coordenada y (função faceXZ) 
\end{itemize}

Consideremos agora as divisões:
\newline
O processo por detrás das divisões das faces da caixa passa por dividir cada uma das faces em N retângulos, sendo este N o número de divisões pretendidas.

\begin{figure}[H]
\centering
\includegraphics[height=7cm]{caixaStacks1.png}
\end{figure}

Seguindo a face [A B D C] enunciada em cima, desta forma, começamos por desenhar o retângulo [A B B' A'] através da função \textit{faceXY}(visto que a mesma desenha 2 triângulos que formam um paralelogramo cujos lados formam 90º entre si), que representa a primeira \textit{stack} da face em causa, sendo que $|$yA'-yA$|$=$|$yB'-yB$|$=yI/stacks (sendo por exemplo yA o valor da coordenada y no ponto A').

\begin{figure}[H]
\centering
\includegraphics[height=7cm]{caixaStacks2.png}
\end{figure}

Na próxima iteração passamos a desenhar o retângulo [A' B' B'' A''] e por aí adiante, até concluirmos o números de \textit{stack's} que queremos obter.
\newline
Nesta face, o eixo que faz variar as divisões é o y, já no caso da face superior e da inferior este eixo passa a ser o x, mas seguindo sempre a mesma teoria.

\subsection{Esfera (Sphere)}
A esfera é o modelo mais complexo dos envolvidos. Neste modelo, mais uma vez, o centro foi colocado na origem. O número de vértices necessários para a esfera é calculado da seguinte maneira:
\begin{enumerate}
    \item a esfera é formada por y \textit{stacks}
    \item cada \textit{stack} é formada por x \textit{slices}
    \item cada \textit{slice} possui 2 triângulos que formam a parede que liga à \textit{stack} superior
    \item cada triângulo tem 3 pontos
    \item nro. total de pontos=6*x*y
\end{enumerate}

De notar que no código desenvolvido o número de \textit{stacks} é dividido por dois (metade para a parte superior, metade para a parte inferior) e, como tal, o cálculo é efetuado com 12*\textit{stacks}*\textit{slices}.


O cálculo dos pontos que forma as laterais da esfera e do cone é feita com recurso à função:
\begin{Verbatim}
    void genWalls(int fd, int sliceCount, float radius, float curRadius, 
                    float y, float angle, float delta, float top,int tpbt)
\end{Verbatim}

Para tal esta calcula os dois triângulos que formam a superfície de cada uma das figuras (cone e esfera).
\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{genWallsDemo.jpg}
    \caption{Superfície desenhada por cada iteração do loop da função \texttt{genWalls}}
\end{figure}

Tendo em conta as seguintes assunções:
\begin{itemize}
    \item \texttt{nextRadius} raio da \textit{stack} seguinte
    \item \texttt{nextStackY} valor da coordenada y para os pontos da \textit{stack} seguinte
    \item \texttt{curRadius} raio da \textit{stack} atual
    \item \texttt{y} valor da coordenada y da \textit{stack} atual
    \item \texttt{angle} amplitude de cada \textit{slice} que compõem a \textit{stack}
\end{itemize}
segue que:
\\

$A=(nextRadius*\sin(curAngle),nextStackY,nextRadius*\cos(curAngle))$

$B=(nextRadius*\sin(curAngle+angle),nextStackY,nextRadius*\cos(curAngle+angle))$

$C=(curRadius*\sin(curAngle),y,curRadius*\cos(curAngle))$

$D=(curRadius*\sin(curAngle+angle),y,curRadius*\cos(curAngle+angle))$


(\textbf{conf.} \ref{PolarCoordinates}-Coordenadas Polares)
\\

O parametro \texttt{tpbt} é usado para indicar se a \textit{stack} a ser desenhada pertence ao extremo superior(1), extremo inferior(-1) ou se é uma \textit{stack} intermédia por forma a impedir que nos extremos sejam calculados o dobro dos pontos necessários. O parâmetro \texttt{top} é usado para determinar se a função está a ser chamada para gerar parte da esfera ou parte do cone para poder realizar a normalização quando se tratar do primeiro caso, sendo também usado, no caso da esfera, para determinar se está a ser calculada a metade superior ou a metade inferior.

Inicialmente são calculados os pontos que formam a metade superior da esfera. Visto tratar-se de uma esfera procedemos à normalização dos pontos antes de os escrevermos no ficheiro de configuração. A normalização tem como objetivo manter a distância dos triângulos a serem desenhados em relação à origem (\textbf{i.e} centro da esfera) igual ao raio mantendo, no entanto, o ângulo entre estes.

\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{beforeNorm.png}
    \caption{Pré-normalização}
\end{figure}

\begin{Verbatim}[fontsize=\small]    
    float dist=sqrt(cur.x*cur.x+cur.y*cur.y+cur.z*cur.z);
    float dx,dy,dz;
    dx=(cur.x*radius)/dist;
    dy=(cur.y*radius)/dist;
    dz=(cur.z*radius)/dist;
    normPoint.x=dx;
    normPoint.y=dy;
    normPoint.z=dz;
    return normPoint;
\end{Verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{afterNorm.png}
    \caption{Pós-normalização}
\end{figure}

Este mesmo processo é depois aplicado à metade inferior da esfera, permitindo assim a obtenção de uma esfera completa. Uma particularidade desta figura é o facto de não ser necessário calcular os pontos correspondentes a cada uma das \textit{stacks} já que estas não são visíveis do exterior, como tal apenas são calculados os pontos referentes às paredes.

\begin{figure}[H]
    \centering
    \includegraphics[height=7cm]{sphereFinal.png}
    \caption{Resultado obtido usando como parâmetros 1 50 50}
\end{figure}

\subsection{Cone (Cone)}
O cone, tal como a esfera, é um dos modelos mais complexos, tanto em termos de cálculo dos pontos necessários como também da quantidade dos mesmos. No caso do cone, o centro da base foi colocado na origem do referencial. O número de pontos necessário à configuração do modelo do cone é calculado da seguinte maneira:
\begin{enumerate}
    \item o número de pontos da superfície lateral é calculado da mesma maneira que o número de pontos usados para a esfera(6*\textit{stacks}*\textit{slices})
    \item a base é constituída por s \textit{slices}
    \item cada \textit{slice} (da base) é constituída por 3 pontos
    \item nro. total de pontos=3*\textit{slices} + 6*\textit{stacks}*\textit{slices}
\end{enumerate}

Como já foi referido, a função \texttt{genWalls} é usada para calcular os pontos que compõem a superfície lateral do cone. No entanto, visto que no cone não existe a noção de raio, não é necessário normalizar os pontos, isto é conseguido através do parâmetro \texttt{deltaH} que corresponde à variação no eixo dos yy entre \textit{stacks} consecutivas e que, no caso da esfera, é igual ao valor de deltaR (variação do raio entre \textit{stacks} consecutivas) sendo por isso passado um valor menor ou igual a 0 caso se trate da metade superior ou inferior respetivamente, permitindo assim a seguinte condição:

\begin{Verbatim}
    else if(top>0.f) nextStackY=y+top;
    ...
    if(top<=0.f)curP=normalize(curP,radius);
\end{Verbatim}

Por fim é gerada a base do cone que consiste em numa aproximação a um círculo por meio de s \textit{slices}, cada uma delas um triângulo. Também neste caso são usadas coordenadas polares (\textbf{conf.} \ref{PolarCoordinates}) para calcular os pontos que constituem cada \textit{slice}.

\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{circleStack.png}
    \caption{Aproximação de \textit{stack} a círculo}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[height=7cm]{coneFinal.png}
    \caption{Resultado obtido usando como parâmetros 2 2 100 100} 
\end{figure}

\newpage

\subsection{Engine}
Em termos de bibliotecas, no engine são utilizadas as seguintes:
\begin{itemize}
    \item Libxml2: Parser XML utilizado devido à sua alta utilização bem como simplicidade
    \item OpenGL: Usado para desenhar sendo a sua utilização justificada por ser open-source e devido à presença de boa documentação
    \item Glut: Biblioteca de "colagem" entre OpenGL e SO
    \item Glew: Necessário para a utilização de VBO's
\end{itemize}
Portanto, com recurso ao mesmo (libxml2) obtivemos do ficheiro XML e pela ordem apresentada no mesmo, os ficheiros em que cada um possui pontos referentes a um poliedro/polígono, sendo este ficheiros possíveis de ser gerados pelo generator atrás referido. 
Para guardar estes pontos é utilizado uma estrutura (Points) que é uma lista ligada, sendo cada elemento constituído por:
\begin{itemize}
    \item Um array com todas as coordenadas dos pontos disponibilizados por determinado ficheiro
    \item O número de pontos que essas coordenadas "geram"
    \item Um apontador para a próxima estrutura (ficheiro seguinte)
\end{itemize}
De modo a desenhar os pontos correspondentes aos presentes nos ficheiros e agora também nos arrays, é usado VBO's facilitando e melhorando a performance. As figuras são desenhadas por um conjunto de triângulos, e, como tal, a cada 3 pontos é desenhado um. 
Foi também implementado, recorrendo a coordenadas polares, a possibilidade de mover a câmara:
\begin{itemize}
    \item Rodar horizontalmente à esquerda: tecla seta esquerda
    \item Rodar horizontalmente à direita: tecla seta direita
    \item Rodar verticalmente para cima: tecla seta cima
    \item Rodar verticalmente para baixo: tecla seta baixo
    \item Aproximar: tecla 'w'
    \item Afastar: tecla 's'
\end{itemize}
Para além disso, carregando na tecla 'm' é alterado consecutivamente o modo de display dos polígonos, alternando entre FILL (a cheio), LINE (em linhas) e POINT (apenas pontos).

\newpage

\section{2ª Fase}

\subsection{Objetivo}
A segunda fase do projeto consiste em implementar, no componente \textit{Engine}, a possbilidade de tratar os ficheiros \textit{XML} que especificam transformações geométricas aplicadas a um conjunto de modelos que pertençam ao mesmo grupo. 
\newline
As transformações geométricas suportadas são:
\begin{itemize}
    \item \textit{translate}: translação 
    \item \textit{rotate}: rotação
    \item \textit{scale}: escala 
\end{itemize}
sendo estas obrigatoriamente referentes a um determinado grupo indicado pela \textit{tag} \textit{$<$group$>$} tendo ainda em conta que a sua ordem é relevante.

\subsection{Tratamento de dados}
Tendo em conta a nova estrutura dos ficheiros \textit{XML} foi implementada uma nova estrutura de dados(\textit{transforms}) para guardar informações relativas às transformações indicadas nestes que, em conjunto com a estrutura já definida(\textit{modelPoints}) permite armazenar todos os dados necessários à renderização das cenas descritas.
Sendo assim, a estrutura de dados \textit{transforms} tem a seguinte forma:
\begin{verbatim}
typedef struct transforms{
    char t;
    float *args;
    struct transforms *next;
}*Transforms;
\end{verbatim}
Tal como a estrutura \textit{modelPoints}, esta lista ligada também é percorrida na fase de renderização. O campo \textit{t} serve para guardar qual o tipo de transformação em causa na altura da renderização enunciada em cima, podendo tomar qualquer um dos seguintes valores:
\begin{itemize}
    \item 't' para realizar um \textit{translate} (necessários os parâmetros X, Y e Z)
    \item 'r' para realizar um \textit{rotate} (necessários os parâmetros Angle, X, Y e Z)
    \item 's' para realizar um \textit{scale} (necessários os parâmetros X, Y e Z)
    \item 'u' para iniciar um novo grupo, fazendo \textit{push} da matriz
    \item 'o' para terminar um grupo, fazendo \textit{pop} da matriz
    \item 'm' para indicar um grupo models
\end{itemize}
Já o \textit{array} de \textit{float's (args)} guarda os parâmetros a utilizar na transformação, sendo que o seu tamanho varia consoante a transformação a aplicar:
\begin{itemize}
    \item 3: \textit{translate} e \textit{scale}
    \item 4: \textit{rotate}
    \item \textbf{NULL}(0): \textit{push} e \textit{pop}
    \item 1: grupo models guardando o número de modelos
\end{itemize}

\subsection{Implementação}
Para o tratamento dos conjuntos de transformações possíveis de utlização numa cena, para o tipo de transformação em uso é chamada uma das seguintes funções:
\begin{itemize}
    \item void translate(xmlNodePtr cur, Transforms *t)
    \item void rotate(xmlNodePtr cur, Transforms *t)
    \item void scale(xmlNodePtr cur, Transforms *t)
\end{itemize}
Por exemplo, no caso da transformação em causa se tratar de um \textit{translate}, o armazenamento da informação a usar na estrutura enunciada em cima é realizado recorrendo à função:
\begin{verbatim}
void translate(xmlNodePtr cur, Transforms *t){
    Transforms auxT=(Transforms)malloc(sizeof(struct transforms));
    auxT->t = 't';
    auxT->args =(float*)malloc(sizeof(float)*3);
    auxT->args[0]= (xmlGetProp(cur,(const xmlChar*)"X")!=NULL) ? 
                        atof(xmlGetProp(cur,(const xmlChar*)"X")) : 0;
    auxT->args[1]= (xmlGetProp(cur,(const xmlChar*)"Y")!=NULL) ? 
                        atof(xmlGetProp(cur,(const xmlChar*)"Y")) : 0;
    auxT->args[2]= (xmlGetProp(cur,(const xmlChar*)"Z")!=NULL) ? 
                        atof(xmlGetProp(cur,(const xmlChar*)"Z")) : 0;
    auxT->next=NULL;
    *t=auxT;
}
\end{verbatim}
Sendo assim, o caracter que identifica esta processo é o 't' e o número de parâmetros a realizar nesta transformação é 3 (\textit{auxT-$>$args =(float*)malloc(sizeof(float)*3);}).
\newline
Para a informação em:
\begin{verbatim}
<translate X="5" Y="0" Z="2" />
\end{verbatim}
precisamos de guardar o valor 5 em auxT-$>$args[0], 0 em auxT-$>$args[1] e 2 em auxT-$>$args[2].
\newline
As funções para as outras duas transformações geométricas seguem a mesma lógica e raciocínio.
Para o caso do caracter 'm' (grupo models) é chamada a função parseModels de modo a guardar os modelos na estrutura Points *models referida na fase anterior.

\subsection{Renderização}
A função \textit{draw} decide qual das tranformações/ações tomar tendo como base o caracter 't' de tipo das transformações:
\begin{verbatim}
    while(auxT){
        switch(auxT->t){
            case 'u':
                glPushMatrix();
                break;
            case 't':
                glTranslatef(auxT->args[0],auxT->args[1],auxT->args[2]);
                break;
            case 'r':
                glRotatef(auxT->args[0],auxT->args[1],auxT->args[2],auxT->args[3]);
                break;
            case 's':
                glScalef(auxT->args[0],auxT->args[1],auxT->args[2]);
                break;
            case 'm':
                drawModels(init,init+(int)auxT->args[0]);
                init= init + (int)auxT->args[0];
                break;
            case 'o':
                glPopMatrix();
                break;
            default:
                break;
        }
        auxT= auxT -> next;
    }
\end{verbatim} 
No caso do tipo ser 'm' é utilizada a função \textit{drawModels} que desenha os modelos correspondentes:
\begin{verbatim}
while(auxM && i<end){
    glBufferData(GL_ARRAY_BUFFER,(auxM->size)*sizeof(float),auxM->points,GL_STATIC_DRAW);
    glDrawArrays(GL_TRIANGLES,0,auxM->size);
    auxM = auxM->next;
    i++;
}
\end{verbatim}
O número de modelos presente em args quando o tipo é 'm' permite saber que modelos presentes em Points *models deve-se desenhar, visto que os mesmos são guardados na altura do parse pela ordem de receção, basta assim saber em cada grupo models quantos havia. É com o intuito de gerir esta situação que exite a variável local init na função \textit{draw}, no qual guarda a partir de que modelo se deve desenhar no preciso momento.

\section{Glossário}

\subsection{Coordenadas Polares}
\label{PolarCoordinates}
No OpenGL as coordenadas são cartesianas e como tal é necessário realizar a conversão caso as coordenadas polares forem usadas. Esta mesma conversão pode ser realizada tendo em atenção o seguinte:

\begin{figure}[ht!]
\centering
\includegraphics[height=12cm]{scan.png}
\end{figure}
%colocar imagem/figura e equações de modo a realizar a conversão
Sendo assim os valores das coordenadas cartesianas do ponto P bem como de w são:
\begin{itemize}
    \item $w = r * cos(\beta)$
    \item $x_{p} = r * cos(\beta) * sin(\alpha)$
    \item $y_{p} = r * sin(\beta)$
    \item $z_{p} = r * cos(\beta) * cos(\alpha)$
\end{itemize}

\subsection{Vertex Buffer Objects (VBOs)}
Numa fase inicial do trabalho foi tomada a decisão de ler o ficheiro XML a cada chamada da função \texttt{renderScene}, ou seja, no pior dos casos, tantas vezes quanto o \textit{refresh rate} do monitor. Isto representava no entanto um grande \textit{bottleneck} em casos em que o ficheiro fosse de tamanho considerável e os modelos em causa complexos. Para limitar este comportamento recorreu-se ao uso de \texttt{arrays} que armazenam as coordenadas de cada ponto sendo que cada modelo, representado por um conjunto de pontos, se encontra armazenado numa estrutura do tipo \texttt{modelPoints}:
\begin{Verbatim}
    typedef struct modelPoints {
        float *points;
        int size;
        struct modelPoints *next;
    }*Points;
\end{Verbatim}
Os modelos encontram-se armazenados numa lista ligada que é percorrida na fase de renderização. Nesta altura são usados VBOs que permitem armazenar os dados para renderização na memória do GPU ao invés da memória central apresentando, por isso, ganhos de performance significativos em relação à renderização imediata.

\begin{Verbatim}
    glBufferData(GL_ARRAY_BUFFER,(auxM->size)*sizeof(float),auxM->points,GL_STATIC_DRAW);
    glDrawArrays(GL_TRIANGLES,0,auxM->size);
    auxM = auxM->next;
\end{Verbatim}

\subsection{First Person Camera - FPC}
Na segunda fase deste projeto optamos por implementar o modo de \textit{First Person Camera}. Este sistema de visualização permite observar os modelos construídos de um modo diferente e confere um maior realismo ao \textit{Engine}, tornando o programa um pouco mais completo. A implementação desta mesma câmara foi realizada de modo a que ao clicar na tecla \textit{'t'} se possa alterar entre o modo de vista por nós já implementado anteriormente e este novo modo.
\newline
Dentro deste modo de visualização, utilizamos as teclas:
\begin{itemize}
    \item \textit{'w'} para mover a câmara para a frente
    \item \textit{'s'} para mover a câmara para trás
    \item \textit{'a'} para mover a câmara para a esquerda
    \item \textit{'d'} para mover a câmara para a direita
    \item setas direita e esquerda para efetuar rotação no sentido pretendido
\end{itemize}

\newpage

\section{Conclusão}
Tendo em conta o trabalho realizado e o uso de VBO's de modo a desenhar os pontos fica por realizar a validação dos parâmetros passados como input ao \textit{Generator} nomeadamente a verificação da positividade do número de slices e stacks do cone. 
A segunda fase compreendeu a construção de novos ficheiros de teste visto que os anteriormente apresentados não cumpriam a nova sintaxe. É de destacar o ficheiro \textit{solarSytem} que especifca uma cena que representa o sistema solar. Optamos também por implementar o modo de visualização \textit{First Person Camera} que adiciona um maior realismo ao programa. Dos aspetos a melhorar no trabalho realizado destaca-se a verificação da sintaxe do ficheiro XML em relação à sua correção. 

\newpage

\section{Referências}
stackoverflow.com/questions/7687148/drawing-sphere-in-opengl-without-using-glusphere
\newline
cpp.libhunt.com/compare-tinyxml2-vs-libxml2
\newline
www.xmlsoft.org/html/index.html
\newline
www.xmlsoft.org/html/libxml-tree.html
\newline
www.xmlsoft.org/html/libxml-parser.html

\end{document}
