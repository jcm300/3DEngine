\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{amsmath}

\begin{document}

\title{\vspace*{\fill}3D Engine}
\author{João Vieira (a78468) \and José Martins (a78821) \and Miguel Quaresma (a77049) \and Simão Barbosa (a77689)}
\date{%
    Universidade do Minho\\
    Computação Gráfica\\[2ex]%
    \today\vspace*{\fill}
}
\maketitle

\newpage

\tableofcontents

\newpage

\section{Introdução}
Este documento serve de documentação à implementação do generator bem como engine desenvolvidos com o intuito de no futuro ser possível a construção de sistemas planetários virtualmente e graficamente.

\newpage

\section{1ª Fase}

\subsection{Generator}

O Generator é o programa responsável por criar os ficheiros pretendidos pelo utilizador, estes contêm os pontos necessários para o Engine conseguir interpretar e "desenhar" os modelos pretendidos.
O programa está construído de forma a poder responder a pedidos relacionados com 4 objetos:
\begin{itemize}
    \item Um plano em XZ, que recebe como parâmetros x e z
        \begin{verbatim}
exº : ./generator plane 2 4 plane.3d
        \end{verbatim}
    \item Uma caixa, que recebe como parâmetros x, y, z e opcionalmente o número de divisões da mesma
        \begin{verbatim}
exº : ./generator box 2 3 2 box.3d
exº : ./generator box 2 3 2 5 box.3d
        \end{verbatim}
    \item Uma esfera, que recebe o raio, o número de slices e de stacks como parâmetros
        \begin{verbatim}
exº : ./generator sphere 3 10 20 sphere.3d
        \end{verbatim}
    \item Um cone, que recebe o seu raio e altura, bem como o número de slices e stacks como parâmetros
        \begin{verbatim}
exº : ./generator cone 2 4 10 20 cone.3d
        \end{verbatim}
\end{itemize}
Para além disto, optamos por também seguir a sugestão do enunciado e imprimir na primeira linha dos ficheiros (que contém os pontos a desenhar) o número de pontos que este contém. Isto permitirá alocar o espaço necessário aos \textit{arrays} usados para VBO's por forma a aumentar a performance do motor.

\subsection{Plano (Plane)}

O plano é o modelo mais simples das opções apresentadas, sabendo logo de partida que recebendo apenas os seus dois parâmetros (x e z) apenas é necessário desenhar 2 triângulos para representar o mesmo, ou seja, apenas necessitámos de preencher o ficheiro desejado com 6 pontos, de modo a ser tratado de forma pretendida pelo Engine.

\begin{figure}[ht!]
\centering
\includegraphics[height=7cm]{plane.png}
\caption{Resultado obtido passando o ficheiro gerado pelo Generator com os parâmetros x=2 e z=4 ao Engine}
\end{figure}

\subsubsection{Em termos matemáticos}
Seja:
\begin{itemize}
    \item x: valor da aresta paralela ao eixo x
    \item z: valor da aresta paralela ao eixo z
\end{itemize}
De modo a desenhar 2 triângulos são necessários 6 pontos:
\begin{itemize}
    \item triângulo 1
        \begin{itemize}
            \item ponto 1: (-x/2,0,z/2)
            \item ponto 2: (-x/2,0,-z/2)
            \item ponto 3: (x/2,0,z/2)
        \end{itemize}
    \item triângulo 2
        \begin{itemize}
            \item ponto 1: (-x/2,0,-z/2)
            \item ponto 2: (x/2,0,-z/2)
            \item ponto 3: (x/2,0,z/2)
        \end{itemize}
\end{itemize}

\begin{figure}[ht!]
\centering
\includegraphics[height=7cm]{planeMath.png}
\end{figure}

\subsection{Caixa (Box)}

Na caixa foi feita a assunção de que o seu centro se encontra na origem do gráfico ou seja, no ponto com coordenadas (0,0,0).
Tendo isto em conta, é-nos útil dividir os parâmetros recebidos das dimensões pretendidas por 2, sendo assim utilizados esses mesmos valores para cada um dos pontos positivos e negativos do eixo em causa.
Interpretamos as divisões opcionais da caixa (d) como sendo utilizadas para dividir as faces laterais da caixa em d divisões (no eixo y), e também em d divisões nas faces inferiores e superiores (no eixo x).
Tendo uma caixa 6 faces, e considerando que cada face é um paralelogramo cujos lados formam um ângulo de 90º entre si, é fácil calcular qual o número de pontos necessários a imprimir para ser possível desenhar o modelo:
\begin{itemize}
    \item 1 paralelogramo cujos lados formam um ângulo de 90º entre si é desenhado recorrendo a 2 triângulos
    \item 1 triângulo é desenhado recorrendo a 3 pontos
    \item Logo, cada paralelogramo cujos lados formam um ângulo de 90º entre si necessita de 6 pontos
    \item Com a componente opcional das divisões, cada face passa assim a ter d paralelogramos cujos lados formam um ângulo de 90º entre si.
    \item Ou seja, nº de pontos total = (2 * d + 4 * d) * 6
\end{itemize}
O processo com as divisões é simples, por exemplo, nas faces laterais da caixa, declaramos 2 variáveis y1 e y2 (sendo neste caso as divisões feitas no eixo y), começamos por calcular a variação em altura que cada divisão tem (var\_y = y/d) e atribuímos os valores:
\begin{itemize}
    \item y1 = -y;
    \item y2 = -y + var\_y;
\end{itemize}
A partir daqui e com a utilização de um ciclo com a inicialização da uma variável i a 0 e enquanto a mesma for menor que o número de divisões pretendidas d, utilizamos as funções criadas por nós para obter os pontos dos paralelogramos cujos lados formam um ângulo de 90º entre si/divisões das faces da caixa progressivamente (neste caso, faceYZ() e faceXY()), incrementando o valor de i, e aumentando em var\_y os valores de y1 e y2 no fim de cada iteração.

\begin{figure}[ht!]
\centering
\includegraphics[height=7cm]{box.png}
\caption{Resultado obtido passando o ficheiro gerado pelo Generator com os parâmetros correspondentes a uma box com 5 divisões ao Engine}
\end{figure}

\subsubsection{Em termos Matemáticos}
Não considerando divisões, ou seja apenas 2 triângulos por face, seja:
\begin{itemize}
    \item xI: valor das arestas paralelas ao eixo x (input 1)
    \item yI: valor das arestas paralelas ao eixo y (input 2)
    \item zI: valor das arestas paralelas ao eixo z (input 3)
\end{itemize}
Visto que a Box tem de estar centrada na origem estes valores são divididos por 2 de modo a facilitar os cálculos:
\begin{itemize}
    \item x=xI/2
    \item y=yI/2
    \item z=zI/2
\end{itemize}
Com base na seguinte figura:
\begin{figure}[H]
    \centering
    \includegraphics[height=10cm]{boxMath1.png}
\end{figure}
Os vértices da box são:
\begin{itemize}
    \item A = (-x,-y,z)
    \item B = (x,-y,z)
    \item C = (-x,y,z)
    \item D = (x,y,z)
    \item E = (-x,y,-z)
    \item F = (-x,-y,-z)
    \item G = (x,-y,-z)
    \item H = (x,y,-z)
\end{itemize}
Consideremos agora apenas as faces ABCD e EFGH:
\begin{figure}[H]
    \centering
    \includegraphics[height=5cm]{boxMath2.png}
\end{figure}
Para desenhar as faces(2 triângulos por cada face) as ordens dos pontos seria, por exemplo:
\begin{figure}[H]
    \centering
    \includegraphics[height=5cm]{boxMath3.png}
\end{figure}
Entre os pontos B e G e entre os pontos C e E apenas é alterado a coordenada z que é simétrica. Sendo assim, na função faceXY podemos (chamando duas vezes a função, uma com zParâmetro=z e outra com zParâmetro=-z) desenhar as duas faces sendo que, os pontos B e G são desenhados pela mesma expressão(x,-y,zParâmetro) e os C e E também(-x,y,zParâmetro). Para os outros pontos é usado um if e consoante o valor de z é desenhado os pontos correspondentes:
\begin{verbatim}
//triângulo 1 da face ABCD(z>0) ou triângulo 2 da face EFGH(z<0)
(x,-y,zParâmetro) //desenhar B ou G
(-x,y,zParâmetro) // desenhar C ou E
if(z>0) (-x,-y,zParâmetro) //desenhar A
else (x,y,zParâmetro) //desenhar H

//triângulo 2 da face ABCD(z>0) ou triângulo 1 da face EFGH(z<0)
(x,-y,zParâmetro) //desenhar B ou G
if(z>0) (x,y,zParâmetro) //desenhar D
else (-x,-y,zParâmetro) //desenhar F
(-x,y,zParâmetro) // desenhar C ou E
\end{verbatim}
Isto é aplicado às outras faces mudando a coordenada simétrica:
\begin{itemize}
    \item faces paralelas a YZ: coordenada x (função faceYZ)
    \item faces paralelas a XZ: coordenada y (função faceXZ) 
\end{itemize}

Consideremos agora as divisões:
\newline
O processo por detrás das divisões das faces da caixa passa por dividir cada uma das faces em N retângulos, sendo este N o número de divisões pretendidas.

\begin{figure}[H]
\centering
\includegraphics[height=7cm]{caixaStacks1.png}
\end{figure}

Seguindo a face [A B D C] enunciada em cima, desta forma, começamos por desenhar o retângulo [A B B' A'] através da função \textit{faceXY}(visto que a mesma desenha 2 triângulos que formam um paralelogramo cujos lados formam 90º entre si), que representa a primeira \textit{stack} da face em causa, sendo que $|$yA'-yA$|$=$|$yB'-yB$|$=yI/stacks (sendo por exemplo yA o valor da coordenada y no ponto A').

\begin{figure}[H]
\centering
\includegraphics[height=7cm]{caixaStacks2.png}
\end{figure}

Na próxima iteração passamos a desenhar o retângulo [A' B' B'' A''] e por aí adiante, até concluirmos o números de \textit{stack's} que queremos obter.
\newline
Nesta face, o eixo que faz variar as divisões é o y, já no caso da face superior e da inferior este eixo passa a ser o x, mas seguindo sempre a mesma teoria.

\subsection{Esfera (Sphere)}
A esfera é o modelo mais complexo dos envolvidos. Neste modelo, mais uma vez, o centro foi colocado na origem. O número de vértices necessários para a esfera é calculado da seguinte maneira:
\begin{enumerate}
    \item a esfera é formada por y \textit{stacks}
    \item cada \textit{stack} é formada por x \textit{slices}
    \item cada \textit{slice} possui 2 triângulos que formam a parede que liga à \textit{stack} superior
    \item cada triângulo tem 3 pontos
    \item nro. total de pontos=6*x*y
\end{enumerate}

De notar que no código desenvolvido o número de \textit{stacks} é dividido por dois (metade para a parte superior, metade para a parte inferior) e, como tal, o cálculo é efetuado com 12*\textit{stacks}*\textit{slices}.


Inicialmente são calculados os pontos que formam a metade superior da esfera, usando para isso a função \texttt{genWalls}. Visto tratar-se de uma esfera procedemos à normalização dos pontos antes de os escrevermos no ficheiro de configuração. A normalização tem como objetivo manter a distância dos triângulos a serem desenhados em relação à origem (\textbf{i.e} centro da esfera) igual ao raio mantendo, no entanto, o ângulo entre estes.

\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{beforeNorm.png}
    \caption{Pré-normalização}
\end{figure}

\begin{Verbatim}[fontsize=\small]    
    float dist=sqrt(cur.x*cur.x+cur.y*cur.y+cur.z*cur.z);
    float dx,dy,dz;
    dx=(cur.x*radius)/dist;
    dy=(cur.y*radius)/dist;
    dz=(cur.z*radius)/dist;
    normPoint.x=dx;
    normPoint.y=dy;
    normPoint.z=dz;
    return normPoint;
\end{Verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[height=4cm]{afterNorm.png}
    \caption{Pós-normalização}
\end{figure}

Este mesmo processo é depois aplicado à metade inferior da esfera, permitindo assim a obtenção de uma esfera completa. Uma particularidade desta figura é o facto de não ser necessário calcular os pontos correspondentes a cada uma das \textit{stacks} já que estas não são visíveis do exterior, como tal apenas são calculados os pontos referentes às paredes.

\begin{figure}[H]
    \centering
    \includegraphics[height=7cm]{sphereFinal.png}
    \caption{Resultado obtido usando como parâmetros 1 50 50}
\end{figure}

\subsection{Cone (Cone)}
O cone, tal como a esfera, é um dos modelos mais complexos, tanto em termos de cálculo dos pontos necessários como também da quantidade dos mesmos. No caso do cone, o centro da base foi colocado na origem do referencial. O número de pontos necessário à configuração do modelo do cone é calculado da seguinte maneira:
\begin{enumerate}
    \item o número de pontos da superfície lateral é calculado da mesma maneira que o número de pontos usados para a esfera(6*\textit{stacks}*\textit{slices})
    \item a base é constituída por s \textit{slices}
    \item cada \textit{slice} (da base) é constituída por 3 pontos
    \item nro. total de pontos=3*\textit{slices} + 6*\textit{stacks}*\textit{slices}
\end{enumerate}

Tal como na esfera, a função genWalls é usada para calcular os pontos que compõem a superfície lateral do cone no entanto, visto que no cone não existe a noção de raio, não é necessário normalizar os pontos. Isto é conseguido através do parâmetro \texttt{deltaH} que corresponde à variação no eixo dos yy entre \textit{stacks} consecutivas e que, no caso da esfera, é igual ao valor de deltaR (variação do raio entre \textit{stacks} consecutivas) sendo por isso passado um valor menor(se se tratar da metade superior) ou igual(se se tratar da metade inferior) a 0 neste último caso permitindo assim a seguinte condição:

\begin{Verbatim}
    else if(top>0.f) nextStackY=y+top;
    ...
    if(top<=0.f)curP=normalize(curP,radius);
\end{Verbatim}

Por fim é gerada a base do cone que consiste em gerar uma aproximação a um círculo constituído por s \textit{slices}, sendo cada uma delas um triângulo.


\begin{figure}[H]
    \centering
    \includegraphics[height=7cm]{coneFinal.png}
    \caption{Resultado obtido usando como parâmetros 2 2 100 100} 
\end{figure}

\newpage

\subsection{Engine}
Em termos de bibliotecas, no engine são utilizadas as seguintes:
\begin{itemize}
    \item Libxml2: Parser XML utilizado devido à sua alta utilização bem como simplicidade
    \item OpenGL: Usado para desenhar sendo a sua utilização justificada por ser open-source e devido à presença de boa documentação
    \item Glut: Biblioteca de "colagem" entre OpenGL e SO
    \item Glew: Necessário para a utilização de VBO's
\end{itemize}
Portanto, com recurso ao mesmo (libxml2) obtivemos do ficheiro XML e pela ordem apresentada no mesmo, os ficheiros em que cada um possui pontos referentes a um poliedro/polígono, sendo este ficheiros possíveis de ser gerados pelo generator atrás referido. 
Para guardar estes pontos é utilizado uma estrutura (Points) que é uma lista ligada, sendo cada elemento constituído por:
\begin{itemize}
    \item Um array com todas as coordenadas dos pontos disponibilizados por determinado ficheiro
    \item O número de pontos que essas coordenadas "geram"
    \item Um apontador para a próxima estrutura (ficheiro seguinte)
\end{itemize}
De modo a desenhar os pontos correspondentes aos presentes nos ficheiros e agora também nos arrays, é usado VBO's facilitando e melhorando a performance. As figuras são desenhadas por um conjunto de triângulos, e, como tal, a cada 3 pontos é desenhado um. 
Foi também implementado, recorrendo a coordenadas polares, a possibilidade de mover a câmara:
\begin{itemize}
    \item Rodar horizontalmente à esquerda: tecla seta esquerda
    \item Rodar horizontalmente à direita: tecla seta direita
    \item Rodar verticalmente para cima: tecla seta cima
    \item Rodar verticalmente para baixo: tecla seta baixo
    \item Aproximar: tecla 'w'
    \item Afastar: tecla 's'
\end{itemize}
Para além disso, carregando na tecla 'm' é alterado consecutivamente o modo de display dos polígonos, alternando entre FILL (a cheio), LINE (em linhas) e POINT (apenas pontos).

\newpage

\section{2ª Fase}

\subsection{Objetivo}
Nesta fase do projeto, o objetivo passa por implementar no Engine as funcionalidades capazes de tratar os ficheiros \textit{XML} onde a cena por este pretendida tem a sua informação no formato de uma árvore, onde cada nodo da mesma faz referência a um conjunto de transformações geométricas e opcionalmente a um conjunto de modelos, tendo para isto em atenção que um dado nodo pode ter vários filhos.
\newline
As transformações geométricas que se pretendem tratar são o \textit{translate}, o \textit{rotate} e o \textit{scale}, sendo que estas apenas podem existir dentro de um determinado grupo (\textit{$<$group$>$}) e a sua ordem é relevante.

\subsection{Tratamento de dados}
A juntar à estrutura criada por nós na fase anterior para armazenar os modelos a desenhar (\textit{modelPoints}), foi agora adicionada uma nova estrutua de dados que nos permita guardar as informações relativas às transformações que um dado ficheiro \textit{XML} requisita.
Sendo assim, a estrutura de dados \textit{transforms} tem a seguinte implementação:
\begin{verbatim}
typedef struct transforms{
    char t;
    float *args;
    struct transforms *next;
}*Transforms;
\end{verbatim}
Tal como a estrutura dos modelos, esta lista ligada também é percorrida na fase de renderização. O caracter \textit{t} serve para guardar qual o tipo de transformação em causa na altura da renderização enunciada em cima, podendo tomar qualquer um dos seguintes valores:
\begin{itemize}
    \item 't' para realizar um \textit{translate} (necessários os parâmetros X, Y e Z)
    \item 'r' para realizar um \textit{rotate} (necessários os parâmetros Angle, X, Y e Z)
    \item 's' para realizar um \textit{scale} (necessários os parâmetros X, Y e Z)
    \item 'u' para iniciar um novo grupo, fazendo \textit{push} da matriz
    \item 'o' para terminar um grupo, fazendo \textit{pop} da matriz
\end{itemize}
Já o \textit{array} de \textit{float's args} guarda os parâmetros a utilizar na transformação, podendo o seu tamanho ser 3 (\textit{translate} e \textit{scale}), 4 (\textit{rotate}) ou \textit{NULL} (no caso do \textit{push} e \textit{pop}).

\subsection{Implementação}
Para o tratamento dos conjuntos de transformações possíveis de utlização numa cena, para o tipo de transformação em uso é chamada uma das seguintes funções:
\begin{itemize}
    \item void translate(xmlNodePtr cur, Transforms *t)
    \item void rotate(xmlNodePtr cur, Transforms *t)
    \item void scale(xmlNodePtr cur, Transforms *t)
\end{itemize}
Por exemplo, no caso da transformação em causa se tratar de um \textit{translate}, o armazenamento da informação a usar na estrutura enunciada em cima é realizado recorrendo à função:
\begin{verbatim}
void translate(xmlNodePtr cur, Transforms *t){
 Transforms auxT=(Transforms)malloc(sizeof(struct transforms));
 auxT->t = 't';
 auxT->args =(float*)malloc(sizeof(float)*3);
 auxT->args[0]= (xmlGetProp(cur,(const xmlChar*)"X")!=NULL) ? atof(xmlGetProp(cur,(const xmlChar*)"X")) : 0;
 auxT->args[1]= (xmlGetProp(cur,(const xmlChar*)"Y")!=NULL) ? atof(xmlGetProp(cur,(const xmlChar*)"Y")) : 0;
 auxT->args[2]= (xmlGetProp(cur,(const xmlChar*)"Z")!=NULL) ? atof(xmlGetProp(cur,(const xmlChar*)"Z")) : 0;$<$translate X="5" Y="0" Z="2" /$>$
 auxT->next=NULL;
 *t=auxT;
}
\end{verbatim}
Sendo assim, o caracter que identifica esta processo é o 't' e o número de parâmetros a realizar nesta transformação é 3 (\textit{auxT-$>$args =(float*)malloc(sizeof(float)*3);}).
\newline
Para a informação em:
\begin{verbatim}
<translate X="5" Y="0" Z="2" />
\end{verbatim}
precisamos de guardar o valor 5 em auxT-$>$args[0], 0 em auxT-$>$args[1] e 2 em auxT-$>$args[2].
\newline
As funções para as outras duas transformações geométricas seguem a mesma lógica e raciocínio.

\section{Glossário}

\subsection{Coordenadas Polares}
No OpenGL as coordenadas são cartesianas e como tal é necessário realizar a conversão caso as coordenadas polares forem usadas. Esta mesma conversão pode ser realizada tendo em atenção o seguinte:

\begin{figure}[ht!]
\centering
\includegraphics[height=12cm]{scan.png}
\end{figure}
%colocar imagem/figura e equações de modo a realizar a conversão
Sendo assim os valores das coordenadas cartesianas do ponto P bem como de w são:
\begin{itemize}
    \item $w = r * cos(\beta)$
    \item $x_{p} = r * cos(\beta) * sin(\alpha)$
    \item $y_{p} = r * sin(\beta)$
    \item $z_{p} = r * cos(\beta) * cos(\alpha)$
\end{itemize}

\subsection{Vertex Buffer Objects (VBOs)}
Numa fase inicial do trabalho foi tomada a decisão de ler o ficheiro XML a cada chamada da função \texttt{renderScene}, ou seja, no pior dos casos, tantas vezes quanto o \textit{refresh rate} do monitor. Isto representava no entanto um grande \textit{bottleneck} em casos em que o ficheiro fosse de tamanho considerável e os modelos em causa complexos. Para limitar este comportamento recorreu-se ao uso de \texttt{arrays} que armazenam as coordenadas de cada ponto sendo que cada modelo, representado por um conjunto de pontos, se encontra armazenado numa estrutura do tipo \texttt{modelPoints}:
\begin{Verbatim}
    typedef struct modelPoints {
        float *points;
        int size;
        struct modelPoints *next;
    }*Points;
\end{Verbatim}
Os modelos encontram-se armazenados numa lista ligada que é percorrida na fase de renderização. Nesta altura são usados VBOs que permitem armazenar os dados para renderização na memória do GPU ao invés da memória central apresentando, por isso, ganhos de performance significativos em relação à renderização imediata.

\begin{Verbatim}
    glBufferData(GL_ARRAY_BUFFER,(auxM->size)*sizeof(float),auxM->points,GL_STATIC_DRAW);
    glDrawArrays(GL_TRIANGLES,0,auxM->size);
    auxM = auxM->next;
\end{Verbatim}

\newpage

\section{Conclusão}
Apesar do bom trabalho realizado, cumprindo o estipulado no enunciado e sendo que já é usado VBO's de modo a desenhar os pontos, fica por realizar a verificação dos parâmetros passados como input ao generator, visto que, por exemplo o mesmo aceita valores negativos para as slices e stacks do cone.

\newpage

\section{Referências}
stackoverflow.com/questions/7687148/drawing-sphere-in-opengl-without-using-glusphere
\newline
cpp.libhunt.com/compare-tinyxml2-vs-libxml2
\newline
www.xmlsoft.org/html/index.html
\newline
www.xmlsoft.org/html/libxml-tree.html
\newline
www.xmlsoft.org/html/libxml-parser.html

\end{document}
